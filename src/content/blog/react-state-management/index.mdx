---
title: "React State Management"
description: "Bro, do you even lift?"
pubDate: "Nov 18 2023"
heroImage: "/blog-placeholder-3.jpg"
---

import Example1 from "./components/example-1/Root";
import Example2 from "./components/example-2/Root";

_TLDR: Extract state from components, don't lift it up._

<hr />

I have a love-hate relationship with React.
I often think it is a wonderful library, making it easy to get started with something.
Before you know it, you went down a rabbit hole, and have built something marvelous.

But then there are times when I think things are weird, counter-intuitive and unnecessarily hard.
One of those things is state management.

Let us imagine we have states that we want to share/manage between components to separate concerns
and simplify each component. There are multiple ways how to achieve this.
Here is an interactive example:

<Example1 client:load />

The standard, <a href="https://react.dev/learn/sharing-state-between-components" target="_blank"> recommended way</a>,
is to use the <a href="https://react.dev/reference/react/useState" target="_blank"> useState</a>
hook and _lift the state up_ to a common ancestor. Then, you can prop-drill (or use a <a href="https://react.dev/reference/react/useContext" target="_blank"> context</a>)
to pass the state down to the components that need it.

This is implemented in the component `BranchA`.
The state is declared in the component `BranchA`.
The state's value is passed down as a prop to `LeaveAA` and the setter function to `LeaveAB`.
But if you click on the `X*2` button you'll notice that not only the component `LeaveAA`,
where the value is used, is re-rendered[^1], but also `LeaveAB` and `BranchA`.

[^1]: Rendered in the VDOM. The actual DOM will only be updated after reconciliation.

Now let's take a look at `BranchB`.
Here we use the zustand library to manage the state.
We declare the state _outside_ our components and _inject_ them into the components that need it.
That means that only the `LeaveBA` receives the state's value, while the `LeaveBB` receives the setter function.
Big difference! Thanks to that, only the component `LeaveBA` is re-rendered when clicking on the `Y*2` button.

Let's look at another example:

<Example2 client:load />

Here, the components that read the state (`LeaveAA`, `LeaveAB`) are further away from the components that update the state
(`LeaveBA`, `LeaveBB`).
So we lifted the state up once further, to the `Root` component, and prop-drilled our value/setter down to the leaves.
And now the difference: when you click on `X*2`, ALL components are re-rendered.
But when you click on `Y*2`, still only the `LeaveBA` is re-rendered.

Now imagine having a large application with complex components, complex states and complex effects.
Being able to surgically re-render only the components that need to be updated, without having to use
any other features like <a href="https://react.dev/reference/react/memo" target="_blank">memo</a>,
is an insane improvement. And at the same time, it improves (IMO) readability by separating concerns and splitting-up
complexity into smaller, more understandable/manageable pieces.

<b>
  That leaves me to wonder, why is this not the standard way of doing things?
</b>

<hr />

Footnotes:
